<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bonk the Shiba Inu</title>

    <!-- Solana Wallet Adapter Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@solana/wallet-adapter-base@0.15.1/dist/index.iife.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/wallet-adapter-react@0.15.1/dist/index.iife.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@solana/wallet-adapter-wallets@0.15.1/dist/index.iife.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@1.73.0/lib/index.iife.min.js"></script>
    <script src="https://unpkg.com/@solana/spl-token@0.3.8/lib/index.iife.min.js"></script>

    <script type="module">
        import { Buffer } from 'https://cdn.jsdelivr.net/npm/buffer@6.0.3/+esm';
        window.Buffer = Buffer;
    </script>

    <!-- Model Viewer Library -->
    <script type="module" src="https://unpkg.com/@google/model-viewer@latest/dist/model-viewer.min.js"></script>

    <style>
    @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

    @keyframes doggo-float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0px); }
    }
    
    body {
        margin: 0;
        background-color: #1E1E2E;
        color: #FF9500;
        font-family: 'VT323', monospace;
        overflow-x: hidden;
        position: relative;
        background-image: radial-gradient(circle, #2A2A3E 1px, transparent 1px);
        background-size: 20px 20px;
    }
    
    .doggo-bg {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: -1;
        opacity: 0.15;
    }

    /* Chat Terminal Styles */
.chat-container {
    display: flex;
    flex-direction: column;
    height: 250px;
    width: 100%;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    background: rgba(20, 20, 30, 0.5);
    border: 1px solid rgba(255, 149, 0, 0.3);
    border-radius: 4px;
    margin-bottom: 10px;
    height: 180px;
}

.chat-input-container {
    display: flex;
    gap: 10px;
}

.chat-input {
    flex: 4; /* Increased from 1 to 4 to make input field take more space */
    background: rgba(20, 20, 30, 0.5);
    border: 1px solid #FF9500;
    color: #FF9500;
    padding: 8px 12px;
    font-family: 'VT323', monospace;
    font-size: 16px;
    border-radius: 4px;
}

.chat-input::placeholder {
    color: rgba(255, 149, 0, 0.5);
}

.chat-send-btn {
    flex: 0.5; /* Added flex property to control width relative to input */
    width: auto;
    min-width: 60px; /* Reduced from 80px to 60px */
    max-width: 70px; /* Added max-width to prevent from growing too large */
    height: auto;
    padding: 8px 8px; /* Reduced horizontal padding from 15px to 8px */
}

.message {
    margin-bottom: 8px;
    padding: 6px 10px;
    border-radius: 4px;
    max-width: 85%;
    word-wrap: break-word;
}

.user-message {
    background: rgba(255, 149, 0, 0.2);
    align-self: flex-end;
    margin-left: auto;
    border-bottom-right-radius: 0;
}

.bot-message {
    background: rgba(255, 149, 0, 0.1);
    align-self: flex-start;
    margin-right: auto;
    border-bottom-left-radius: 0;
}

.typing-indicator {
    display: inline-block;
    padding: 5px 10px;
    background: rgba(255, 149, 0, 0.1);
    border-radius: 10px;
    margin-bottom: 8px;
}

.dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: #FF9500;
    opacity: 0.6;
    animation: typing 1.4s infinite;
    margin-right: 4px;
}

.dot:nth-child(2) {
    animation-delay: 0.2s;
}

.dot:nth-child(3) {
    animation-delay: 0.4s;
}

@keyframes typing {
    0% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
    100% { transform: translateY(0); }
}
    
    .doggo-particle {
        position: absolute;
        width: 20px;
        height: 20px;
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23FF9500"><path d="M12 2L15 6H9L12 2Z"/></svg>');
        background-size: contain;
        opacity: 0.3;
        animation: doggo-float 3s infinite ease-in-out;
    }
    
    .terminal-window {
        background: rgba(30, 30, 46, 0.9);
        border: 1px solid #FF9500;
        box-shadow: 0 0 10px #FF9500;
        border-radius: 5px;
        padding: 20px;
        margin: 40px 10px 10px 10px;
        position: relative;
    }
    
    .terminal-header {
        position: absolute;
        top: -30px;
        left: 0;
        right: 0;
        height: 30px;
        background: #2A2A3E;
        border: 1px solid #FF9500;
        border-bottom: none;
        border-radius: 5px 5px 0 0;
        display: flex;
        align-items: center;
        padding: 0 10px;
        z-index: 1;
    }
    
    .terminal-title {
        color: #FF9500;
        font-size: 14px;
        margin: 0;
    }
    
    .terminal-info {
        color: #FF9500;
        font-family: 'VT323', monospace;
        font-size: 14px;
        text-align: center;
        margin-top: 15px;
        line-height: 1.4;
        text-shadow: 0 0 5px #FF9500;
        padding: 10px;
        border-top: 1px solid rgba(255, 149, 0, 0.3);
    }

    @keyframes scanline {
        0% { transform: translateY(0); }
        100% { transform: translateY(100vh); }
    }
    
    .scanline {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 2px;
        background: rgba(255, 149, 0, 0.1);
        animation: scanline 6s linear infinite;
        pointer-events: none;
        z-index: 9999;
    }

    .action-btn {
        font-family: 'VT323', monospace;
        font-size: 18px;
        padding: 10px 20px;
        margin: 5px;
        border: 1px solid #FF9500;
        background: #2A2A3E;
        color: #FF9500;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        position: relative;
        overflow: hidden;
        text-shadow: 0 0 5px #FF9500;
        box-shadow: 0 0 10px rgba(255, 149, 0, 0.3);
        border-radius: 8px;
        width: 100%;
        min-width: 150px;
    }
    
    .action-btn:disabled {
        background: #2A2A3E;
        color: #996633;
        border-color: #996633;
        cursor: not-allowed;
    }
    
    .action-btn:hover:not(:disabled) {
        background: #3A3A4E;
        transform: scale(1.05);
    }
    
    .action-btn:active {
        transform: scale(1.02);
    }
    
    #connectWalletBtn {
        background: linear-gradient(145deg, #4A2500, #2A2A3E);
    }
    
    #walletAddress {
        font-size: 14px;
        color: #FF9500;
        margin-top: 8px;
    }
    
    .token-info {
        font-size: 14px;
        color: #FF9500;
        margin-top: 4px;
        font-weight: bold;
    }
    
    .progress-container {
        margin: 15px 0;
        width: 100%;
        height: 25px;
        background: rgba(30, 30, 46, 0.3);
        border: 1px solid #FF9500;
        border-radius: 4px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 0 10px rgba(255, 149, 0, 0.2);
    }
    
    progress {
        width: 100%;
        height: 100%;
        -webkit-appearance: none;
        appearance: none;
        border: none;
        background: transparent;
    }
    
    progress::-webkit-progress-bar {
        background: rgba(255, 149, 0, 0.1);
        border-radius: 4px;
        background-image: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 19px,
            rgba(255, 149, 0, 0.3) 19px,
            rgba(255, 149, 0, 0.3) 20px
        );
    }
    
    progress::-webkit-progress-value {
        background: #FF9500;
        border-radius: 4px;
        box-shadow: 0 0 15px #FF9500;
        background-image: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 19px,
            rgba(255, 149, 0, 1) 19px,
            rgba(255, 149, 0, 1) 20px
        );
    }
    
    .progress-container::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg,
            transparent 0%,
            rgba(255, 149, 0, 0.4) 50%,
            transparent 100%);
        animation: doggo-scan 2s linear infinite;
    }
    
    .progress-container::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            90deg,
            transparent,
            transparent 19px,
            rgba(255, 149, 0, 0.1) 19px,
            rgba(255, 149, 0, 0.1) 20px
        );
    }
    
    @keyframes doggo-flow {
        0% { background-position: 0 0; }
        100% { background-position: 50px 0; }
    }
    
    @keyframes doggo-scan {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
    .time-left {
        font-size: 14px;
        color: #FF9500;
        text-shadow: 0 0 8px #FF9500;
        font-weight: bold;
        position: absolute;
        bottom: -20px;
        left: 0;
    }
    
    #bonkViewer {
        width: 100%;
        height: 400px;
        margin: 20px auto;
    }
    
    .button-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        margin: 10px 0;
    }
    
    .counter-display {
        font-size: 12px;
        color: #FF9500;
        margin-top: 5px;
        text-align: center;
        white-space: nowrap;
    }
    
    #popupContainer {
        position: fixed;
        bottom: 10px;
        left: 10px;
        z-index: 100;
        font-size: 14px;
    }

    .popup-message {
        background: rgba(30, 30, 46, 0.9);
        border: 1px solid #FF9500;
        color: #FF9500;
        padding: 10px 20px;
        margin-top: 8px;
        border-radius: 20px;
        box-shadow: 0 0 10px #FF9500;
        animation: bonk-animation 0.3s ease;
    }
    
    @keyframes bonk-animation {
        0% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
        100% { transform: translate(0); }
    }
    
    .soundcloud-player {
        max-width: 300px;
        height: 60px;
        margin: 10px auto;
    }
    
    #mainContainer {
    margin-top: 10px;
    padding-top: 10px;
}
    
    .level-badge {
        position: absolute;
        top: 5px;
        right: 10px;
        color: #FF9500;
        background: transparent;
        border: none;
        padding: 2px 8px;
        font-size: 12px;
        text-shadow: 0 0 5px #FF9500;
    }
    
    .training-interface-container {
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 20px;
        width: 100%;
        max-width: 800px;
        margin: 0 auto;
    }
    
    .progress-section {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        align-items: start;
        max-width: 100%;
        padding: 0 20px;
    }
    
    .training-interface-container {
        padding: 0;
        width: 100%;
        max-width: 100%;
    }
    
    .progress-container {
        margin: 15px 0;
        width: 100%;
        height: 25px;
    }
    
    .counter-display {
        font-size: 12px;
        color: #FF9500;
        margin-top: 5px;
        text-align: center;
        white-space: nowrap;
    }

    .social-btn {
    text-decoration: none;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    margin-top: 15px;
    font-size: 16px; /* Slightly smaller font */
    height: 30px; /* Reduce height */
    width: 45%; /* Make buttons wider but not full width */
    margin: 10px auto; /* Center buttons with some margin */
}
    
    .social-btn:hover {
        background: #3A3A4E;
        transform: scale(1.05);
        text-decoration: none;
    }
    
    .action-btn {
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .simulation-buttons {
    display: grid;
    grid-template-columns: 1fr 1fr; /* Two equal columns instead of three */
    gap: 15px; /* Slightly larger gap between buttons */
    width: 100%;
    margin-top: 20px;
}

    .soundcloud-doggo {
        position: relative;
        max-width: 300px;
        margin: 10px auto;
        border: 1px solid #FF9500;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: 0 0 10px rgba(255, 149, 0, 0.3);
        background: rgba(30, 30, 46, 0.9);
    }
    
    .soundcloud-doggo iframe {
        position: relative;
        z-index: 2;
        filter: sepia(0.5) hue-rotate(20deg) saturate(1.5);
        mix-blend-mode: color-dodge;
    }
    
    .doggo-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
            45deg,
            rgba(255, 149, 0, 0.1),
            rgba(30, 30, 46, 0.2)
        );
        z-index: 3;
        pointer-events: none;
    }
    
    .soundcloud-doggo::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
            90deg,
            transparent 0px,
            transparent 2px,
            rgba(255, 149, 0, 0.1) 2px,
            rgba(255, 149, 0, 0.1) 4px
        );
        animation: doggo-scan 20s linear infinite;
        z-index: 1;
    }
    </style>
</head>

<body>
    <!-- Doggo Background -->
    <div class="doggo-bg" id="doggoBg"></div>
    <div class="scanline"></div>

    <!-- Added padding div to ensure content starts below viewport top -->
    <div style="padding-top: 0px;"></div>

    <div id="mainContainer">
        <!-- Wallet Connection Terminal -->
        <div class="terminal-window">
            <div class="terminal-header">
                <div class="terminal-title">AI BONK TERMINAL</div>
            </div>
            <div class="button-group">
                <button id="connectWalletBtn" class="action-btn">CONNECT NEURAL NETWORK</button>
                <p id="walletAddress">Network Status: Disconnected</p>
                <div id="trainerLevel" class="level-badge">Level 0: Neural Node Inactive</div>
                <p id="tokenInfo" class="token-info">Required Processing Power: 10,000 $BONK per operation</p>
            </div>
            <div class="terminal-info">
                Bonk Experiment 001<br>
                Use $BONK tokens to train Bonk<br>
                If any bar reaches 0 after 24 hours & Bonk's experiment is over but coin remains active.<br>
                Each Interaction extends the progress for 15minutes
            </div>
        </div>

        <!-- AI Model Viewer Terminal -->
        <div class="terminal-window">
            <div class="terminal-header">
                <div class="terminal-title">AI MODEL VISUALIZATION</div>
            </div>

            <model-viewer id="bonkViewer" src="https://cdn.jsdelivr.net/gh/webdevgf1/bonkkk@master/animated_dog_shiba_inu.glb"
    camera-controls autoplay animation-name="0|sitting_0">
</model-viewer>

            <div class="training-interface-container">
                <div class="progress-section">
                    <div class="button-group">
                        <button id="feedBtn" class="action-btn">GIVE TREAT</button>
                        <div class="progress-container">
                            <progress id="feedProgress" value="100" max="100"></progress>
                            <span id="feedTimeLeft" class="time-left"></span>
                        </div>
                        <div class="counter-display">Total Treats Given: <span id="feedCounter">0</span> â€¢ Time Remaining: <span id="feedTimeLeft2"></span></div>
                    </div>
                    
                    <div class="button-group">
                        <button id="petBtn" class="action-btn">PAT HEAD</button>
                        <div class="progress-container">
                            <progress id="petProgress" value="100" max="100"></progress>
                            <span id="petTimeLeft" class="time-left"></span>
                        </div>
                        <div class="counter-display">Total Pats: <span id="petCounter">0</span> â€¢ Time Remaining: <span id="petTimeLeft2"></span></div>
                    </div>
                    
                    <div class="simulation-buttons">
    <button id="walkBtn" class="action-btn" onclick="document.getElementById('bonkViewer').setAttribute('animation-name', '0|standing_0');">STAND</button>
    <button id="runBtn" class="action-btn" onclick="document.getElementById('bonkViewer').setAttribute('animation-name', '0|shake_0');">SHAKE</button>
    <button id="peckBtn" class="action-btn" onclick="document.getElementById('bonkViewer').setAttribute('animation-name', '0|play_dead_0');">PLAY DEAD</button>
    <button id="sitBtn" class="action-btn" onclick="document.getElementById('bonkViewer').setAttribute('animation-name', '0|rollover_0');">ROLL OVER</button>
</div>
                    <div class="simulation-buttons" style="margin-top: 10px;">
    <a href="https://twitter.com/bonktoken" target="_blank" class="action-btn social-btn">TWITTER</a>
    <a href="https://letsbonk.fun/" target="_blank" class="action-btn social-btn">BUY $BONK</a>
</div>
                </div>
            </div>
        </div>

        <div id="popupContainer"></div>
        <!-- CORRECT STRUCTURE: -->
<!-- Chat Terminal -->
<div class="terminal-window">
    <div class="terminal-header">
        <div class="terminal-title">BONK AI CHAT INTERFACE</div>
    </div>
    <div class="chat-container">
        <div id="chatMessages" class="chat-messages"></div>
        <div class="chat-input-container">
            <input type="text" id="userInput" class="chat-input" placeholder="Talk to Bonk..." />
            <button id="sendMessageBtn" class="action-btn chat-send-btn">SEND</button>
        </div>
    </div>
</div>

        <script type="module">
            import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
            import { getDatabase, ref, set, get, onValue, update } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

            // Update this with your Firebase config
            const firebaseConfig = {
                apiKey: "AIzaSyBgGzLFUTVG3nPZOXa5XWEIRkNJWlGHFSM",
                authDomain: "bonk-7c193.firebaseapp.com",
                databaseURL: "https://bonk-7c193-default-rtdb.firebaseio.com/",
                projectId: "bonk-7c193",
                storageBucket: "bonk-7c193.firebasestorage.app",
                messagingSenderId: "878668958014",
                appId: "1:878668958014:web:a38b7145f80dfcfe7a846f",
                measurementId: "G-3EK9G054FW"
            };
            
            const app = initializeApp(firebaseConfig);
            const db = getDatabase(app);
            
            // Doggo Background Effect
            function createDoggoBackground() {
                const container = document.getElementById('doggoBg');
                const width = window.innerWidth;
                const height = window.innerHeight;
                const particleCount = Math.floor(width * height / 10000);

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'doggo-particle';
                    particle.style.left = Math.random() * width + 'px';
                    particle.style.top = Math.random() * height + 'px';
                    particle.style.animationDelay = (Math.random() * 5) + 's';
                    container.appendChild(particle);
                }
            }

            // Trainer Level System
            const TRAINER_LEVELS = {
                0: 'Neural Node Inactive',
                1: 'Shiba Inu Cadet',
                5: 'Treat Distributor',
                10: 'Doggo Whisperer',
                25: 'Shiba Trainer',
                50: 'Doge Commander',
                100: 'Bonk Master'
            };

            async function updateTrainerLevel(totalInteractions) {
                const level = Object.keys(TRAINER_LEVELS)
                    .map(Number)
                    .reverse()
                    .find(threshold => totalInteractions >= threshold) || 0;

                const levelDisplay = document.getElementById('trainerLevel');
                levelDisplay.innerText = `Level ${level}: ${TRAINER_LEVELS[level]}`;
                levelDisplay.style.textShadow = `0 0 ${level * 2}px #FF9500`;
            }

            const connection = new solanaWeb3.Connection("https://small-fabled-sound.solana-mainnet.quiknode.pro/67aea8bbb493e8b02d169b526c52eda88a5f4a59/", "confirmed");
            let wallet;

            // Token constants - Update with Bonk token details
            const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
            const ASSOCIATED_TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
            const TOKEN_MINT = new solanaWeb3.PublicKey("DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"); // Replace with BONK token mint
            const RECIPIENT = new solanaWeb3.PublicKey("ENA4SDyjwWw6tEywB8UFZB8VSKk3fBpFjMsXZ4rvMf97"); // Replace with your wallet address
            const AMOUNT = 1000000000; // Adjust based on BONK decimals

            // Initialize counters in Firebase
            async function initializeCounters() {
                const countersRef = ref(db, 'counters');
                const snapshot = await get(countersRef);
                if (!snapshot.exists()) {
                    await set(countersRef, {
                        feeds: 0,
                        pets: 0,
                        totalProcessing: 0,
                        uniqueTrainers: {}
                    });
                }

                onValue(ref(db, 'counters'), (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        document.getElementById('feedCounter').innerText = data.feeds || 0;
                        document.getElementById('petCounter').innerText = data.pets || 0;

                        // Update trainer level if wallet is connected
                        if (wallet && wallet.publicKey) {
                            const userInteractions = (data.uniqueTrainers || {})[wallet.publicKey.toString()] || 0;
                            updateTrainerLevel(userInteractions);
                        }
                    }
                });
            }

            // Update counter when action is successful
            async function updateCounter(action) {
                const countersRef = ref(db, 'counters');
                const snapshot = await get(countersRef);
                const currentCounts = snapshot.val() || { feeds: 0, pets: 0 };

                if (action === 'feed') {
                    await update(countersRef, { feeds: (currentCounts.feeds || 0) + 1 });
                } else if (action === 'pet') {
                    await update(countersRef, { pets: (currentCounts.pets || 0) + 1 });
                }
            }

            async function connectWallet() {
                if (window.solana && window.solana.isPhantom) {
                    wallet = window.solana;
                    await wallet.connect();
                    document.getElementById('walletAddress').innerText = `Wallet Address: ${wallet.publicKey}`;
                    enableButtons();
                } else {
                    alert("Please install Phantom wallet.");
                }
            }

            function enableButtons() {
                document.getElementById("feedBtn").disabled = false;
                document.getElementById("petBtn").disabled = false;
            }

            document.getElementById("connectWalletBtn").addEventListener("click", connectWallet);

            async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
                return (await solanaWeb3.PublicKey.findProgramAddress(
                    [
                        walletAddress.toBuffer(),
                        TOKEN_PROGRAM_ID.toBuffer(),
                        tokenMintAddress.toBuffer(),
                    ],
                    ASSOCIATED_TOKEN_PROGRAM_ID
                ))[0];
            }

            async function sendTransaction(action) {
                try {
                    if (!wallet || !wallet.publicKey) {
                        alert("Please connect your wallet first");
                        return;
                    }

                    const userATA = await findAssociatedTokenAddress(wallet.publicKey, TOKEN_MINT);
                    const recipientATA = await findAssociatedTokenAddress(RECIPIENT, TOKEN_MINT);

                    const userATAInfo = await connection.getAccountInfo(userATA);
                    const recipientATAInfo = await connection.getAccountInfo(recipientATA);

                    const transaction = new solanaWeb3.Transaction();

                    if (!recipientATAInfo) {
                        transaction.add(
                            createAssociatedTokenAccountInstruction(
                                wallet.publicKey,
                                recipientATA,
                                RECIPIENT,
                                TOKEN_MINT
                            )
                        );
                    }

                    const transferInstruction = createTransferInstruction(
                        userATA,
                        recipientATA,
                        wallet.publicKey,
                        AMOUNT,
                        [],
                        TOKEN_PROGRAM_ID
                    );

                    transaction.add(transferInstruction);

                    const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
                    transaction.recentBlockhash = blockhash;
                    transaction.feePayer = wallet.publicKey;

                    try {
                        const signed = await wallet.signTransaction(transaction);
                        const signature = await connection.sendRawTransaction(signed.serialize());

                        const confirmation = await connection.confirmTransaction({
                            signature,
                            blockhash,
                            lastValidBlockHeight
                        });

                        if (confirmation.value.err) {
                            throw new Error('Transaction failed to confirm');
                        }

                        await updateProgress(action);
                        await updateCounter(action);
                        addSuccessAnimation(action);
                        showPopupMessage(`${action} successful!`);
                    } catch (err) {
                        console.error("Transaction failed:", err);
                        showPopupMessage(`${action} failed: ${err.message}`);
                    }
                } catch (error) {
                    console.error(`${action} error:`, error);
                    showPopupMessage(`${action} error: ${error.message}`);
                }
            }

            // Add success animation to buttons
            function addSuccessAnimation(action) {
                const button = document.getElementById(`${action}Btn`);
                button.classList.add('success-animation');
                setTimeout(() => button.classList.remove('success-animation'), 500);
            }

            function createAssociatedTokenAccountInstruction(
                payer,
                associatedToken,
                owner,
                mint
            ) {
                return new solanaWeb3.TransactionInstruction({
                    keys: [
                        { pubkey: payer, isSigner: true, isWritable: true },
                        { pubkey: associatedToken, isSigner: false, isWritable: true },
                        { pubkey: owner, isSigner: false, isWritable: false },
                        { pubkey: mint, isSigner: false, isWritable: false },
                        { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
                        { pubkey: solanaWeb3.SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false },
                    ],
                    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                    data: Buffer.from([]),
                });
            }

            function createTransferInstruction(
                source,
                destination,
                owner,
                amount,
                multiSigners = [],
                programId = TOKEN_PROGRAM_ID
            ) {
                const dataLayout = {
                    struct: [
                        { u8: 'instruction' },
                        { u64: 'amount' },
                    ]
                };

                const keys = [
                    { pubkey: source, isSigner: false, isWritable: true },
                    { pubkey: destination, isSigner: false, isWritable: true },
                    { pubkey: owner, isSigner: true, isWritable: false },
                ];

                const data = Buffer.alloc(9);
                data.writeUInt8(3); // Transfer instruction
                data.writeBigUInt64LE(BigInt(amount), 1);

                return new solanaWeb3.TransactionInstruction({
                    keys,
                    programId,
                    data,
                });
            }

            // Enhanced popup message with emojis
            function showPopupMessage(message) {
                const popupContainer = document.getElementById("popupContainer");
                const popupMessage = document.createElement("div");
                popupMessage.className = "popup-message";

                // Add emojis to success messages
                if (message.includes('treat successful')) {
                    message = 'ðŸ¦´ ' + message;
                } else if (message.includes('pat successful')) {
                    message = 'ðŸ• ' + message;
                }

                popupMessage.innerText = message;
                popupContainer.appendChild(popupMessage);
                setTimeout(() => popupMessage.remove(), 3000);
            }

            async function updateProgress(action) {
                const incrementInMilliseconds = 15 * 60 * 1000;
                const actionRef = ref(db, `progress/${action}`);
                const currentTime = Date.now();

                const data = await get(actionRef).then(snapshot => snapshot.val());
                let remainingTime = 24 * 60 * 60 * 1000; // Default to 24 hours

                if (data) {
                    const timeElapsed = currentTime - data.lastUpdated;
                    remainingTime = Math.max(0, data.remainingTime - timeElapsed);
                    remainingTime = Math.min(remainingTime + incrementInMilliseconds, 24 * 60 * 60 * 1000);
                }

                await update(actionRef, {
                    lastUpdated: currentTime,
                    remainingTime
                });
            }

            function loadProgress() {
                ["feed", "pet"].forEach(action => {
                    const actionRef = ref(db, `progress/${action}`);
                    onValue(actionRef, (snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            const progressBar = document.getElementById(`${action}Progress`);
                            const timeElapsed = Date.now() - data.lastUpdated;
                            const currentRemaining = Math.max(0, data.remainingTime - timeElapsed);

                            // This will make the progress bar show actual remaining time
                            const percentage = ((currentRemaining / (24 * 60 * 60 * 1000)) * 100);
                            progressBar.value = percentage;

                            const hoursLeft = Math.floor(currentRemaining / (60 * 60 * 1000));
                            const minutesLeft = Math.floor((currentRemaining % (60 * 60 * 1000)) / (60 * 1000));
                            document.getElementById(`${action}TimeLeft`).innerText = `${hoursLeft}h ${minutesLeft}m left`;
                            document.getElementById(`${action}TimeLeft2`).innerText = `${hoursLeft}h ${minutesLeft}m`;
                        }
                    });
                });
            }
            
            async function initializeProgressBars() {
                const currentTime = Date.now();
                const twelveHoursInMs = 12 * 60 * 60 * 1000;

                const actions = ["feed", "pet"];
                for (const action of actions) {
                    const actionRef = ref(db, `progress/${action}`);
                    const snapshot = await get(actionRef);
                    if (!snapshot.exists()) {
                        await set(actionRef, {
                            lastUpdated: currentTime - twelveHoursInMs,
                            remainingTime: 24 * 60 * 60 * 1000
                        });
                    }
                }
            }

            document.getElementById("feedBtn").addEventListener("click", () => sendTransaction("feed"));
            document.getElementById("petBtn").addEventListener("click", () => sendTransaction("pet"));

            function setBonkAnimation(animationName) {
    const modelViewer = document.getElementById("bonkViewer");
    modelViewer.animationName = animationName;
    
    // If you want to reset to sitting after playing an animation:
    if (animationName !== "0|sitting_0") {
        setTimeout(() => {
            modelViewer.animationName = "0|sitting_0";
        }, 3000); // Wait 3 seconds before returning to sitting
    }
}

            document.getElementById("walkBtn").addEventListener("click", () => setBonkAnimation("0|standing_0"));
document.getElementById("runBtn").addEventListener("click", () => setBonkAnimation("0|shake_0"));
document.getElementById("peckBtn").addEventListener("click", () => setBonkAnimation("0|play_dead_0"));
document.getElementById("sitBtn").addEventListener("click", () => setBonkAnimation("0|rollover_0"));

            function getRandomUsername() {
                const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
                let username = "User-";
                for (let i = 0; i < 5; i++) {
                    username += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return username;
            }

            function showRandomPopup() {
                const actions = ["gave Bonk a treat", "pat Bonk's head"];
                const randomAction = actions[Math.floor(Math.random() * actions.length)];
                const username = getRandomUsername();

                const popupContainer = document.getElementById("popupContainer");

                const popupMessage = document.createElement("div");
                popupMessage.className = "popup-message";
                popupMessage.innerText = `${username} ${randomAction}`;

                popupContainer.appendChild(popupMessage);

                setTimeout(() => {
                    popupMessage.remove();
                }, 2000);

                const randomInterval = Math.floor(Math.random() * (8000 - 3000 + 1)) + 3000;
                setTimeout(showRandomPopup, randomInterval);
            }

            // Initialize everything
            loadProgress();
            initializeProgressBars();
            initializeCounters();
            showRandomPopup();
            // Initialize doggo background
            createDoggoBackground();

            // Window resize handler for doggo background
            window.addEventListener('resize', () => {
                const container = document.getElementById('doggoBg');
                container.innerHTML = '';
                createDoggoBackground();
            });

            // Bonk Chat Interface with Anthropic API
const chatMessages = document.getElementById('chatMessages');
const userInput = document.getElementById('userInput');
const sendMessageBtn = document.getElementById('sendMessageBtn');
let conversation = []; // Store conversation history

// Add a message to the chat
function addMessage(text, isUser) {
    const messageElement = document.createElement('div');
    messageElement.classList.add('message');
    messageElement.classList.add(isUser ? 'user-message' : 'bot-message');
    messageElement.textContent = text;
    
    chatMessages.appendChild(messageElement);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Show typing indicator
function showTypingIndicator() {
    const indicator = document.createElement('div');
    indicator.id = 'typingIndicator';
    indicator.className = 'typing-indicator';
    indicator.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
    chatMessages.appendChild(indicator);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Hide typing indicator
function hideTypingIndicator() {
    const indicator = document.getElementById('typingIndicator');
    if (indicator) {
        indicator.remove();
    }
}

// Send a message to the API and get a response
async function sendMessage() {
    const message = userInput.value.trim();
    if (message === '') return;
    
    // Add user message to chat
    addMessage(message, true);
    userInput.value = '';
    
    // Store user message in conversation history
    conversation.push({ role: "user", content: message });
    
    // Show typing indicator
    showTypingIndicator();
    
    try {
        // This URL works for Vercel deployments - it points to your own API route
        const response = await fetch('/api/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ message, conversation }),
        });
        
        const data = await response.json();
        
        // Hide typing indicator
        hideTypingIndicator();
        
        // Add bot response to chat
        addMessage(data.response, false);
        
        // Store bot response in conversation history
        conversation.push({ role: "assistant", content: data.response });
        
    } catch (error) {
        console.error('Error:', error);
        hideTypingIndicator();
        addMessage("Woof! Sorry, I'm having trouble connecting to my brain right now. *sad puppy eyes*", false);
    }
}

// Event listeners
sendMessageBtn.addEventListener('click', sendMessage);
userInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        sendMessage();
    }
});

// Add an initial greeting from Bonk
setTimeout(() => {
    addMessage("Woof! I'm Bonk the AI Shiba Inu! How can I help you today? *wags tail excitedly*", false);
}, 1000);
        </script>
    </div> <!-- Close mainContainer div -->
</body>
</html>
